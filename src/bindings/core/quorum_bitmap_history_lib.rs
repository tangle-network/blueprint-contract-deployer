#![allow(clippy::all, clippy::pedantic, clippy::nursery, warnings, unknown_lints, rustdoc::all, elided_lifetimes_in_paths)]
use QuorumBitmapHistoryLib::*;

/**

Generated by the following Solidity interface...
```solidity
interface QuorumBitmapHistoryLib {
    error BitmapUpdateIsAfterBlockNumber();
    error BitmapUpdateNotFound();
    error NextBitmapUpdateIsBeforeBlockNumber();
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "error",
    "name": "BitmapUpdateIsAfterBlockNumber",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BitmapUpdateNotFound",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NextBitmapUpdateIsBeforeBlockNumber",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod QuorumBitmapHistoryLib {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610817610034600b8282823980515f1a607314602857634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe7300000000000000000000000000000000000000003014608060405260043610610055575f3560e01c80631a3894e914610059578063224c4ae8146100895780638192610f146100a9578063ae1d62db146100bc575b5f5ffd5b61006c6100673660046105bc565b6100dd565b6040516001600160c01b0390911681526020015b60405180910390f35b61009c610097366004610608565b61014d565b60405161008091906106eb565b61006c6100b7366004610733565b6101ff565b8180156100c7575f5ffd5b506100db6100d636600461076d565b6102e2565b005b5f818152602083905260408120548082036100fb575f915050610147565b5f8381526020859052604090206101136001836107ae565b81548110610123576101236107cd565b5f91825260209091200154600160401b90046001600160c01b031691506101479050565b92915050565b60605f825167ffffffffffffffff81111561016a5761016a6105f4565b604051908082528060200260200182016040528015610193578160200160208202803683370190505b5090505f5b83518110156101f4576101c586868684815181106101b8576101b86107cd565b60200260200101516104a0565b8282815181106101d7576101d76107cd565b63ffffffff90921660209283029190910190910152600101610198565b5090505b9392505050565b5f838152602085905260408120805482919084908110610221576102216107cd565b5f91825260209182902060408051606081018252929091015463ffffffff8082168085526401000000008304821695850195909552600160401b9091046001600160c01b0316918301919091529092508516101561029257604051636cb19aff60e01b815260040160405180910390fd5b602081015163ffffffff1615806102b85750806020015163ffffffff168463ffffffff16105b6102d55760405163bbba60cb60e01b815260040160405180910390fd5b6040015195945050505050565b5f8281526020849052604081205490819003610388575f83815260208581526040808320815160608101835263ffffffff43811682528185018681526001600160c01b03808a16958401958652845460018101865594885295909620915191909201805495519351909416600160401b0267ffffffffffffffff9383166401000000000267ffffffffffffffff199096169190921617939093171691909117905561049a565b5f8381526020859052604081206103a06001846107ae565b815481106103b0576103b06107cd565b5f918252602090912001805490915063ffffffff4381169116036103f257805467ffffffffffffffff16600160401b6001600160c01b03851602178155610498565b805467ffffffff0000000019166401000000004363ffffffff9081168281029390931784555f8781526020898152604080832081516060810183529687528683018481526001600160c01b038b81169389019384528254600181018455928652939094209651960180549351915196851667ffffffffffffffff199094169390931793169093029190911767ffffffffffffffff16600160401b93909216929092021790555b505b50505050565b5f81815260208490526040812054815b818110156105235760016104c482846107ae565b6104ce91906107ae565b92508463ffffffff16865f8681526020019081526020015f208463ffffffff16815481106104fe576104fe6107cd565b5f9182526020909120015463ffffffff161161051b5750506101f8565b6001016104b0565b5060405162461bcd60e51b815260206004820152605c60248201527f5265676973747279436f6f7264696e61746f722e67657451756f72756d42697460448201527f6d6170496e6465784174426c6f636b4e756d6265723a206e6f206269746d617060648201527f2075706461746520666f756e6420666f72206f70657261746f72496400000000608482015260a40160405180910390fd5b5f5f604083850312156105cd575f5ffd5b50508035926020909101359150565b803563ffffffff811681146105ef575f5ffd5b919050565b634e487b7160e01b5f52604160045260245ffd5b5f5f5f6060848603121561061a575f5ffd5b8335925061062a602085016105dc565b9150604084013567ffffffffffffffff811115610645575f5ffd5b8401601f81018613610655575f5ffd5b803567ffffffffffffffff81111561066f5761066f6105f4565b8060051b604051601f19603f830116810181811067ffffffffffffffff8211171561069c5761069c6105f4565b6040529182526020818401810192908101898411156106b9575f5ffd5b6020850194505b838510156106dc578435808252602095860195909350016106c0565b50809450505050509250925092565b602080825282518282018190525f918401906040840190835b8181101561072857835163ffffffff16835260209384019390920191600101610704565b509095945050505050565b5f5f5f5f60808587031215610746575f5ffd5b843593506020850135925061075d604086016105dc565b9396929550929360600135925050565b5f5f5f6060848603121561077f575f5ffd5b833592506020840135915060408401356001600160c01b03811681146107a3575f5ffd5b809150509250925092565b8181038181111561014757634e487b7160e01b5f52601160045260245ffd5b634e487b7160e01b5f52603260045260245ffdfea264697066735822122087d02ef2a6b4382cf481d9dc9aee0c7b2a90bc84f67454d6c63ac3567378ad1e64736f6c634300081b0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x08\x17a\x004`\x0B\x82\x82\x829\x80Q_\x1A`s\x14`(WcNH{q`\xE0\x1B_R_`\x04R`$_\xFD[0_R`s\x81S\x82\x81\xF3\xFEs\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14`\x80`@R`\x046\x10a\0UW_5`\xE0\x1C\x80c\x1A8\x94\xE9\x14a\0YW\x80c\"LJ\xE8\x14a\0\x89W\x80c\x81\x92a\x0F\x14a\0\xA9W\x80c\xAE\x1Db\xDB\x14a\0\xBCW[__\xFD[a\0la\0g6`\x04a\x05\xBCV[a\0\xDDV[`@Q`\x01`\x01`\xC0\x1B\x03\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0\x9Ca\0\x976`\x04a\x06\x08V[a\x01MV[`@Qa\0\x80\x91\x90a\x06\xEBV[a\0la\0\xB76`\x04a\x073V[a\x01\xFFV[\x81\x80\x15a\0\xC7W__\xFD[Pa\0\xDBa\0\xD66`\x04a\x07mV[a\x02\xE2V[\0[_\x81\x81R` \x83\x90R`@\x81 T\x80\x82\x03a\0\xFBW_\x91PPa\x01GV[_\x83\x81R` \x85\x90R`@\x90 a\x01\x13`\x01\x83a\x07\xAEV[\x81T\x81\x10a\x01#Wa\x01#a\x07\xCDV[_\x91\x82R` \x90\x91 \x01T`\x01`@\x1B\x90\x04`\x01`\x01`\xC0\x1B\x03\x16\x91Pa\x01G\x90PV[\x92\x91PPV[``_\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x01jWa\x01ja\x05\xF4V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x01\x93W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x83Q\x81\x10\x15a\x01\xF4Wa\x01\xC5\x86\x86\x86\x84\x81Q\x81\x10a\x01\xB8Wa\x01\xB8a\x07\xCDV[` \x02` \x01\x01Qa\x04\xA0V[\x82\x82\x81Q\x81\x10a\x01\xD7Wa\x01\xD7a\x07\xCDV[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R`\x01\x01a\x01\x98V[P\x90P[\x93\x92PPPV[_\x83\x81R` \x85\x90R`@\x81 \x80T\x82\x91\x90\x84\x90\x81\x10a\x02!Wa\x02!a\x07\xCDV[_\x91\x82R` \x91\x82\x90 `@\x80Q``\x81\x01\x82R\x92\x90\x91\x01Tc\xFF\xFF\xFF\xFF\x80\x82\x16\x80\x85Rd\x01\0\0\0\0\x83\x04\x82\x16\x95\x85\x01\x95\x90\x95R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xC0\x1B\x03\x16\x91\x83\x01\x91\x90\x91R\x90\x92P\x85\x16\x10\x15a\x02\x92W`@Qcl\xB1\x9A\xFF`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[` \x81\x01Qc\xFF\xFF\xFF\xFF\x16\x15\x80a\x02\xB8WP\x80` \x01Qc\xFF\xFF\xFF\xFF\x16\x84c\xFF\xFF\xFF\xFF\x16\x10[a\x02\xD5W`@Qc\xBB\xBA`\xCB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@\x01Q\x95\x94PPPPPV[_\x82\x81R` \x84\x90R`@\x81 T\x90\x81\x90\x03a\x03\x88W_\x83\x81R` \x85\x81R`@\x80\x83 \x81Q``\x81\x01\x83Rc\xFF\xFF\xFF\xFFC\x81\x16\x82R\x81\x85\x01\x86\x81R`\x01`\x01`\xC0\x1B\x03\x80\x8A\x16\x95\x84\x01\x95\x86R\x84T`\x01\x81\x01\x86U\x94\x88R\x95\x90\x96 \x91Q\x91\x90\x92\x01\x80T\x95Q\x93Q\x90\x94\x16`\x01`@\x1B\x02g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x83\x16d\x01\0\0\0\0\x02g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x96\x16\x91\x90\x92\x16\x17\x93\x90\x93\x17\x16\x91\x90\x91\x17\x90Ua\x04\x9AV[_\x83\x81R` \x85\x90R`@\x81 a\x03\xA0`\x01\x84a\x07\xAEV[\x81T\x81\x10a\x03\xB0Wa\x03\xB0a\x07\xCDV[_\x91\x82R` \x90\x91 \x01\x80T\x90\x91Pc\xFF\xFF\xFF\xFFC\x81\x16\x91\x16\x03a\x03\xF2W\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`@\x1B`\x01`\x01`\xC0\x1B\x03\x85\x16\x02\x17\x81Ua\x04\x98V[\x80Tg\xFF\xFF\xFF\xFF\0\0\0\0\x19\x16d\x01\0\0\0\0Cc\xFF\xFF\xFF\xFF\x90\x81\x16\x82\x81\x02\x93\x90\x93\x17\x84U_\x87\x81R` \x89\x81R`@\x80\x83 \x81Q``\x81\x01\x83R\x96\x87R\x86\x83\x01\x84\x81R`\x01`\x01`\xC0\x1B\x03\x8B\x81\x16\x93\x89\x01\x93\x84R\x82T`\x01\x81\x01\x84U\x92\x86R\x93\x90\x94 \x96Q\x96\x01\x80T\x93Q\x91Q\x96\x85\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x94\x16\x93\x90\x93\x17\x93\x16\x90\x93\x02\x91\x90\x91\x17g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`@\x1B\x93\x90\x92\x16\x92\x90\x92\x02\x17\x90U[P[PPPPV[_\x81\x81R` \x84\x90R`@\x81 T\x81[\x81\x81\x10\x15a\x05#W`\x01a\x04\xC4\x82\x84a\x07\xAEV[a\x04\xCE\x91\x90a\x07\xAEV[\x92P\x84c\xFF\xFF\xFF\xFF\x16\x86_\x86\x81R` \x01\x90\x81R` \x01_ \x84c\xFF\xFF\xFF\xFF\x16\x81T\x81\x10a\x04\xFEWa\x04\xFEa\x07\xCDV[_\x91\x82R` \x90\x91 \x01Tc\xFF\xFF\xFF\xFF\x16\x11a\x05\x1BWPPa\x01\xF8V[`\x01\x01a\x04\xB0V[P`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\\`$\x82\x01R\x7FRegistryCoordinator.getQuorumBit`D\x82\x01R\x7FmapIndexAtBlockNumber: no bitmap`d\x82\x01R\x7F update found for operatorId\0\0\0\0`\x84\x82\x01R`\xA4\x01`@Q\x80\x91\x03\x90\xFD[__`@\x83\x85\x03\x12\x15a\x05\xCDW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[\x805c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x05\xEFW__\xFD[\x91\x90PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[___``\x84\x86\x03\x12\x15a\x06\x1AW__\xFD[\x835\x92Pa\x06*` \x85\x01a\x05\xDCV[\x91P`@\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06EW__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x06UW__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06oWa\x06oa\x05\xF4V[\x80`\x05\x1B`@Q`\x1F\x19`?\x83\x01\x16\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x06\x9CWa\x06\x9Ca\x05\xF4V[`@R\x91\x82R` \x81\x84\x01\x81\x01\x92\x90\x81\x01\x89\x84\x11\x15a\x06\xB9W__\xFD[` \x85\x01\x94P[\x83\x85\x10\x15a\x06\xDCW\x845\x80\x82R` \x95\x86\x01\x95\x90\x93P\x01a\x06\xC0V[P\x80\x94PPPPP\x92P\x92P\x92V[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x07(W\x83Qc\xFF\xFF\xFF\xFF\x16\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x07\x04V[P\x90\x95\x94PPPPPV[____`\x80\x85\x87\x03\x12\x15a\x07FW__\xFD[\x845\x93P` \x85\x015\x92Pa\x07]`@\x86\x01a\x05\xDCV[\x93\x96\x92\x95P\x92\x93``\x015\x92PPV[___``\x84\x86\x03\x12\x15a\x07\x7FW__\xFD[\x835\x92P` \x84\x015\x91P`@\x84\x015`\x01`\x01`\xC0\x1B\x03\x81\x16\x81\x14a\x07\xA3W__\xFD[\x80\x91PP\x92P\x92P\x92V[\x81\x81\x03\x81\x81\x11\x15a\x01GWcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD\xFE\xA2dipfsX\"\x12 \x87\xD0.\xF2\xA6\xB48,\xF4\x81\xD9\xDC\x9A\xEE\x0C{*\x90\xBC\x84\xF6tT\xD6\xC6:\xC3Vsx\xAD\x1EdsolcC\0\x08\x1B\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x7300000000000000000000000000000000000000003014608060405260043610610055575f3560e01c80631a3894e914610059578063224c4ae8146100895780638192610f146100a9578063ae1d62db146100bc575b5f5ffd5b61006c6100673660046105bc565b6100dd565b6040516001600160c01b0390911681526020015b60405180910390f35b61009c610097366004610608565b61014d565b60405161008091906106eb565b61006c6100b7366004610733565b6101ff565b8180156100c7575f5ffd5b506100db6100d636600461076d565b6102e2565b005b5f818152602083905260408120548082036100fb575f915050610147565b5f8381526020859052604090206101136001836107ae565b81548110610123576101236107cd565b5f91825260209091200154600160401b90046001600160c01b031691506101479050565b92915050565b60605f825167ffffffffffffffff81111561016a5761016a6105f4565b604051908082528060200260200182016040528015610193578160200160208202803683370190505b5090505f5b83518110156101f4576101c586868684815181106101b8576101b86107cd565b60200260200101516104a0565b8282815181106101d7576101d76107cd565b63ffffffff90921660209283029190910190910152600101610198565b5090505b9392505050565b5f838152602085905260408120805482919084908110610221576102216107cd565b5f91825260209182902060408051606081018252929091015463ffffffff8082168085526401000000008304821695850195909552600160401b9091046001600160c01b0316918301919091529092508516101561029257604051636cb19aff60e01b815260040160405180910390fd5b602081015163ffffffff1615806102b85750806020015163ffffffff168463ffffffff16105b6102d55760405163bbba60cb60e01b815260040160405180910390fd5b6040015195945050505050565b5f8281526020849052604081205490819003610388575f83815260208581526040808320815160608101835263ffffffff43811682528185018681526001600160c01b03808a16958401958652845460018101865594885295909620915191909201805495519351909416600160401b0267ffffffffffffffff9383166401000000000267ffffffffffffffff199096169190921617939093171691909117905561049a565b5f8381526020859052604081206103a06001846107ae565b815481106103b0576103b06107cd565b5f918252602090912001805490915063ffffffff4381169116036103f257805467ffffffffffffffff16600160401b6001600160c01b03851602178155610498565b805467ffffffff0000000019166401000000004363ffffffff9081168281029390931784555f8781526020898152604080832081516060810183529687528683018481526001600160c01b038b81169389019384528254600181018455928652939094209651960180549351915196851667ffffffffffffffff199094169390931793169093029190911767ffffffffffffffff16600160401b93909216929092021790555b505b50505050565b5f81815260208490526040812054815b818110156105235760016104c482846107ae565b6104ce91906107ae565b92508463ffffffff16865f8681526020019081526020015f208463ffffffff16815481106104fe576104fe6107cd565b5f9182526020909120015463ffffffff161161051b5750506101f8565b6001016104b0565b5060405162461bcd60e51b815260206004820152605c60248201527f5265676973747279436f6f7264696e61746f722e67657451756f72756d42697460448201527f6d6170496e6465784174426c6f636b4e756d6265723a206e6f206269746d617060648201527f2075706461746520666f756e6420666f72206f70657261746f72496400000000608482015260a40160405180910390fd5b5f5f604083850312156105cd575f5ffd5b50508035926020909101359150565b803563ffffffff811681146105ef575f5ffd5b919050565b634e487b7160e01b5f52604160045260245ffd5b5f5f5f6060848603121561061a575f5ffd5b8335925061062a602085016105dc565b9150604084013567ffffffffffffffff811115610645575f5ffd5b8401601f81018613610655575f5ffd5b803567ffffffffffffffff81111561066f5761066f6105f4565b8060051b604051601f19603f830116810181811067ffffffffffffffff8211171561069c5761069c6105f4565b6040529182526020818401810192908101898411156106b9575f5ffd5b6020850194505b838510156106dc578435808252602095860195909350016106c0565b50809450505050509250925092565b602080825282518282018190525f918401906040840190835b8181101561072857835163ffffffff16835260209384019390920191600101610704565b509095945050505050565b5f5f5f5f60808587031215610746575f5ffd5b843593506020850135925061075d604086016105dc565b9396929550929360600135925050565b5f5f5f6060848603121561077f575f5ffd5b833592506020840135915060408401356001600160c01b03811681146107a3575f5ffd5b809150509250925092565b8181038181111561014757634e487b7160e01b5f52601160045260245ffd5b634e487b7160e01b5f52603260045260245ffdfea264697066735822122087d02ef2a6b4382cf481d9dc9aee0c7b2a90bc84f67454d6c63ac3567378ad1e64736f6c634300081b0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"s\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14`\x80`@R`\x046\x10a\0UW_5`\xE0\x1C\x80c\x1A8\x94\xE9\x14a\0YW\x80c\"LJ\xE8\x14a\0\x89W\x80c\x81\x92a\x0F\x14a\0\xA9W\x80c\xAE\x1Db\xDB\x14a\0\xBCW[__\xFD[a\0la\0g6`\x04a\x05\xBCV[a\0\xDDV[`@Q`\x01`\x01`\xC0\x1B\x03\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0\x9Ca\0\x976`\x04a\x06\x08V[a\x01MV[`@Qa\0\x80\x91\x90a\x06\xEBV[a\0la\0\xB76`\x04a\x073V[a\x01\xFFV[\x81\x80\x15a\0\xC7W__\xFD[Pa\0\xDBa\0\xD66`\x04a\x07mV[a\x02\xE2V[\0[_\x81\x81R` \x83\x90R`@\x81 T\x80\x82\x03a\0\xFBW_\x91PPa\x01GV[_\x83\x81R` \x85\x90R`@\x90 a\x01\x13`\x01\x83a\x07\xAEV[\x81T\x81\x10a\x01#Wa\x01#a\x07\xCDV[_\x91\x82R` \x90\x91 \x01T`\x01`@\x1B\x90\x04`\x01`\x01`\xC0\x1B\x03\x16\x91Pa\x01G\x90PV[\x92\x91PPV[``_\x82Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x01jWa\x01ja\x05\xF4V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x01\x93W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x83Q\x81\x10\x15a\x01\xF4Wa\x01\xC5\x86\x86\x86\x84\x81Q\x81\x10a\x01\xB8Wa\x01\xB8a\x07\xCDV[` \x02` \x01\x01Qa\x04\xA0V[\x82\x82\x81Q\x81\x10a\x01\xD7Wa\x01\xD7a\x07\xCDV[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R`\x01\x01a\x01\x98V[P\x90P[\x93\x92PPPV[_\x83\x81R` \x85\x90R`@\x81 \x80T\x82\x91\x90\x84\x90\x81\x10a\x02!Wa\x02!a\x07\xCDV[_\x91\x82R` \x91\x82\x90 `@\x80Q``\x81\x01\x82R\x92\x90\x91\x01Tc\xFF\xFF\xFF\xFF\x80\x82\x16\x80\x85Rd\x01\0\0\0\0\x83\x04\x82\x16\x95\x85\x01\x95\x90\x95R`\x01`@\x1B\x90\x91\x04`\x01`\x01`\xC0\x1B\x03\x16\x91\x83\x01\x91\x90\x91R\x90\x92P\x85\x16\x10\x15a\x02\x92W`@Qcl\xB1\x9A\xFF`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[` \x81\x01Qc\xFF\xFF\xFF\xFF\x16\x15\x80a\x02\xB8WP\x80` \x01Qc\xFF\xFF\xFF\xFF\x16\x84c\xFF\xFF\xFF\xFF\x16\x10[a\x02\xD5W`@Qc\xBB\xBA`\xCB`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@\x01Q\x95\x94PPPPPV[_\x82\x81R` \x84\x90R`@\x81 T\x90\x81\x90\x03a\x03\x88W_\x83\x81R` \x85\x81R`@\x80\x83 \x81Q``\x81\x01\x83Rc\xFF\xFF\xFF\xFFC\x81\x16\x82R\x81\x85\x01\x86\x81R`\x01`\x01`\xC0\x1B\x03\x80\x8A\x16\x95\x84\x01\x95\x86R\x84T`\x01\x81\x01\x86U\x94\x88R\x95\x90\x96 \x91Q\x91\x90\x92\x01\x80T\x95Q\x93Q\x90\x94\x16`\x01`@\x1B\x02g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x83\x16d\x01\0\0\0\0\x02g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x96\x16\x91\x90\x92\x16\x17\x93\x90\x93\x17\x16\x91\x90\x91\x17\x90Ua\x04\x9AV[_\x83\x81R` \x85\x90R`@\x81 a\x03\xA0`\x01\x84a\x07\xAEV[\x81T\x81\x10a\x03\xB0Wa\x03\xB0a\x07\xCDV[_\x91\x82R` \x90\x91 \x01\x80T\x90\x91Pc\xFF\xFF\xFF\xFFC\x81\x16\x91\x16\x03a\x03\xF2W\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`@\x1B`\x01`\x01`\xC0\x1B\x03\x85\x16\x02\x17\x81Ua\x04\x98V[\x80Tg\xFF\xFF\xFF\xFF\0\0\0\0\x19\x16d\x01\0\0\0\0Cc\xFF\xFF\xFF\xFF\x90\x81\x16\x82\x81\x02\x93\x90\x93\x17\x84U_\x87\x81R` \x89\x81R`@\x80\x83 \x81Q``\x81\x01\x83R\x96\x87R\x86\x83\x01\x84\x81R`\x01`\x01`\xC0\x1B\x03\x8B\x81\x16\x93\x89\x01\x93\x84R\x82T`\x01\x81\x01\x84U\x92\x86R\x93\x90\x94 \x96Q\x96\x01\x80T\x93Q\x91Q\x96\x85\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x94\x16\x93\x90\x93\x17\x93\x16\x90\x93\x02\x91\x90\x91\x17g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`@\x1B\x93\x90\x92\x16\x92\x90\x92\x02\x17\x90U[P[PPPPV[_\x81\x81R` \x84\x90R`@\x81 T\x81[\x81\x81\x10\x15a\x05#W`\x01a\x04\xC4\x82\x84a\x07\xAEV[a\x04\xCE\x91\x90a\x07\xAEV[\x92P\x84c\xFF\xFF\xFF\xFF\x16\x86_\x86\x81R` \x01\x90\x81R` \x01_ \x84c\xFF\xFF\xFF\xFF\x16\x81T\x81\x10a\x04\xFEWa\x04\xFEa\x07\xCDV[_\x91\x82R` \x90\x91 \x01Tc\xFF\xFF\xFF\xFF\x16\x11a\x05\x1BWPPa\x01\xF8V[`\x01\x01a\x04\xB0V[P`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\\`$\x82\x01R\x7FRegistryCoordinator.getQuorumBit`D\x82\x01R\x7FmapIndexAtBlockNumber: no bitmap`d\x82\x01R\x7F update found for operatorId\0\0\0\0`\x84\x82\x01R`\xA4\x01`@Q\x80\x91\x03\x90\xFD[__`@\x83\x85\x03\x12\x15a\x05\xCDW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[\x805c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x05\xEFW__\xFD[\x91\x90PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[___``\x84\x86\x03\x12\x15a\x06\x1AW__\xFD[\x835\x92Pa\x06*` \x85\x01a\x05\xDCV[\x91P`@\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06EW__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x06UW__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06oWa\x06oa\x05\xF4V[\x80`\x05\x1B`@Q`\x1F\x19`?\x83\x01\x16\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x06\x9CWa\x06\x9Ca\x05\xF4V[`@R\x91\x82R` \x81\x84\x01\x81\x01\x92\x90\x81\x01\x89\x84\x11\x15a\x06\xB9W__\xFD[` \x85\x01\x94P[\x83\x85\x10\x15a\x06\xDCW\x845\x80\x82R` \x95\x86\x01\x95\x90\x93P\x01a\x06\xC0V[P\x80\x94PPPPP\x92P\x92P\x92V[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x07(W\x83Qc\xFF\xFF\xFF\xFF\x16\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x07\x04V[P\x90\x95\x94PPPPPV[____`\x80\x85\x87\x03\x12\x15a\x07FW__\xFD[\x845\x93P` \x85\x015\x92Pa\x07]`@\x86\x01a\x05\xDCV[\x93\x96\x92\x95P\x92\x93``\x015\x92PPV[___``\x84\x86\x03\x12\x15a\x07\x7FW__\xFD[\x835\x92P` \x84\x015\x91P`@\x84\x015`\x01`\x01`\xC0\x1B\x03\x81\x16\x81\x14a\x07\xA3W__\xFD[\x80\x91PP\x92P\x92P\x92V[\x81\x81\x03\x81\x81\x11\x15a\x01GWcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD\xFE\xA2dipfsX\"\x12 \x87\xD0.\xF2\xA6\xB48,\xF4\x81\xD9\xDC\x9A\xEE\x0C{*\x90\xBC\x84\xF6tT\xD6\xC6:\xC3Vsx\xAD\x1EdsolcC\0\x08\x1B\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BitmapUpdateIsAfterBlockNumber()` and selector `0x6cb19aff`.
```solidity
error BitmapUpdateIsAfterBlockNumber();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BitmapUpdateIsAfterBlockNumber;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BitmapUpdateIsAfterBlockNumber>
        for UnderlyingRustTuple<'_> {
            fn from(value: BitmapUpdateIsAfterBlockNumber) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for BitmapUpdateIsAfterBlockNumber {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BitmapUpdateIsAfterBlockNumber {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BitmapUpdateIsAfterBlockNumber()";
            const SELECTOR: [u8; 4] = [108u8, 177u8, 154u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BitmapUpdateNotFound()` and selector `0xdbf829a3`.
```solidity
error BitmapUpdateNotFound();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BitmapUpdateNotFound;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BitmapUpdateNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: BitmapUpdateNotFound) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BitmapUpdateNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BitmapUpdateNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BitmapUpdateNotFound()";
            const SELECTOR: [u8; 4] = [219u8, 248u8, 41u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NextBitmapUpdateIsBeforeBlockNumber()` and selector `0xbbba60cb`.
```solidity
error NextBitmapUpdateIsBeforeBlockNumber();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NextBitmapUpdateIsBeforeBlockNumber;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NextBitmapUpdateIsBeforeBlockNumber>
        for UnderlyingRustTuple<'_> {
            fn from(value: NextBitmapUpdateIsBeforeBlockNumber) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NextBitmapUpdateIsBeforeBlockNumber {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NextBitmapUpdateIsBeforeBlockNumber {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NextBitmapUpdateIsBeforeBlockNumber()";
            const SELECTOR: [u8; 4] = [187u8, 186u8, 96u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    ///Container for all the [`QuorumBitmapHistoryLib`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum QuorumBitmapHistoryLibErrors {
        #[allow(missing_docs)]
        BitmapUpdateIsAfterBlockNumber(BitmapUpdateIsAfterBlockNumber),
        #[allow(missing_docs)]
        BitmapUpdateNotFound(BitmapUpdateNotFound),
        #[allow(missing_docs)]
        NextBitmapUpdateIsBeforeBlockNumber(NextBitmapUpdateIsBeforeBlockNumber),
    }
    #[automatically_derived]
    impl QuorumBitmapHistoryLibErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [108u8, 177u8, 154u8, 255u8],
            [187u8, 186u8, 96u8, 203u8],
            [219u8, 248u8, 41u8, 163u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for QuorumBitmapHistoryLibErrors {
        const NAME: &'static str = "QuorumBitmapHistoryLibErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 3usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BitmapUpdateIsAfterBlockNumber(_) => {
                    <BitmapUpdateIsAfterBlockNumber as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BitmapUpdateNotFound(_) => {
                    <BitmapUpdateNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NextBitmapUpdateIsBeforeBlockNumber(_) => {
                    <NextBitmapUpdateIsBeforeBlockNumber as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<QuorumBitmapHistoryLibErrors>] = &[
                {
                    fn BitmapUpdateIsAfterBlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<QuorumBitmapHistoryLibErrors> {
                        <BitmapUpdateIsAfterBlockNumber as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                QuorumBitmapHistoryLibErrors::BitmapUpdateIsAfterBlockNumber,
                            )
                    }
                    BitmapUpdateIsAfterBlockNumber
                },
                {
                    fn NextBitmapUpdateIsBeforeBlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<QuorumBitmapHistoryLibErrors> {
                        <NextBitmapUpdateIsBeforeBlockNumber as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                QuorumBitmapHistoryLibErrors::NextBitmapUpdateIsBeforeBlockNumber,
                            )
                    }
                    NextBitmapUpdateIsBeforeBlockNumber
                },
                {
                    fn BitmapUpdateNotFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<QuorumBitmapHistoryLibErrors> {
                        <BitmapUpdateNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(QuorumBitmapHistoryLibErrors::BitmapUpdateNotFound)
                    }
                    BitmapUpdateNotFound
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<QuorumBitmapHistoryLibErrors>] = &[
                {
                    fn BitmapUpdateIsAfterBlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<QuorumBitmapHistoryLibErrors> {
                        <BitmapUpdateIsAfterBlockNumber as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                QuorumBitmapHistoryLibErrors::BitmapUpdateIsAfterBlockNumber,
                            )
                    }
                    BitmapUpdateIsAfterBlockNumber
                },
                {
                    fn NextBitmapUpdateIsBeforeBlockNumber(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<QuorumBitmapHistoryLibErrors> {
                        <NextBitmapUpdateIsBeforeBlockNumber as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                QuorumBitmapHistoryLibErrors::NextBitmapUpdateIsBeforeBlockNumber,
                            )
                    }
                    NextBitmapUpdateIsBeforeBlockNumber
                },
                {
                    fn BitmapUpdateNotFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<QuorumBitmapHistoryLibErrors> {
                        <BitmapUpdateNotFound as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(QuorumBitmapHistoryLibErrors::BitmapUpdateNotFound)
                    }
                    BitmapUpdateNotFound
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BitmapUpdateIsAfterBlockNumber(inner) => {
                    <BitmapUpdateIsAfterBlockNumber as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BitmapUpdateNotFound(inner) => {
                    <BitmapUpdateNotFound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NextBitmapUpdateIsBeforeBlockNumber(inner) => {
                    <NextBitmapUpdateIsBeforeBlockNumber as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BitmapUpdateIsAfterBlockNumber(inner) => {
                    <BitmapUpdateIsAfterBlockNumber as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BitmapUpdateNotFound(inner) => {
                    <BitmapUpdateNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NextBitmapUpdateIsBeforeBlockNumber(inner) => {
                    <NextBitmapUpdateIsBeforeBlockNumber as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`QuorumBitmapHistoryLib`](self) contract instance.

See the [wrapper's documentation](`QuorumBitmapHistoryLibInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> QuorumBitmapHistoryLibInstance<P, N> {
        QuorumBitmapHistoryLibInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<QuorumBitmapHistoryLibInstance<P, N>>,
    > {
        QuorumBitmapHistoryLibInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        QuorumBitmapHistoryLibInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`QuorumBitmapHistoryLib`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`QuorumBitmapHistoryLib`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct QuorumBitmapHistoryLibInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for QuorumBitmapHistoryLibInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("QuorumBitmapHistoryLibInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > QuorumBitmapHistoryLibInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`QuorumBitmapHistoryLib`](self) contract instance.

See the [wrapper's documentation](`QuorumBitmapHistoryLibInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<QuorumBitmapHistoryLibInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> QuorumBitmapHistoryLibInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> QuorumBitmapHistoryLibInstance<P, N> {
            QuorumBitmapHistoryLibInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > QuorumBitmapHistoryLibInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > QuorumBitmapHistoryLibInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
